10**  GF8 COMPILER ** 
20 G=$0000 S=$C000 R=$5000 ** G=ソース格納 S=EXE格納 R=開始番地
30 L=$7800 P=0            ** 行番号TBL & Work & stac  P=0 途中表示  P=4 途中非表示
40 / "-PASS1-" P=1+P A=S L(2)=G !=100 L(1)=A L(4)=O
50 / "-PASS2-" P=1+P A=S G=L(2) !=100 !=8300
60 / "SOURCE:" ?=G-(L(2)) "(" ??=L(2) "-" ??=G ")" 
70 / "OBJECT:" ?=A-S "(" ??=S "-" ??=A-1 ")" ??=R "-" ??=A-S+R
80 / " WORK :" ?=L(4) "(" ??=L "-" ??=L(4)+2*2+L-1 ")"
90 #=-1
100** 1-2 PASS(コンパイル時、1PASSで行番号の番地を登録、2PASSで飛び先番地決定)
110 U=L+$10 L(5)=9000 ;=P&1=1 O=$20 ** L(0-19)Work L(20-39)Stack L(40--)Label L(5)=BIOS.Entry
120 !=8190 W=$DF !=8230 W=$1FFF !=8200 W=$38 !=8230     ** NOPとSPをセット
130* L(3)=0 ** コメント欄が"-"と"-"の間を読み飛ばすフラグ
200** 行を文に分解して処理
210 V=G:0)*256+G:1)                       ** 行番号(V)を読出し
220 ;=G:0)<$80 #=250                      ** 終了確認
225*  BIOSの実態が存在しない場合、moniのBIOSを呼び出す(但しR<$40以下の場合は重なるので呼び出さない)
230 ;=P&1=1 K=L(5)+1 !=1590 ;=K(J)<>(L(5)+1) ;=R>$40 K=0 @ K=K+1 L(O)=L(5)+K L(O+1)=K*3+5+S-R O=O+2 @=(K>15)
240 W=$C2 !=8230 L(O)=$7FFF L(O+1)=A ]    ** 文章解析終了(Ret) **
250 ;=P=1 / ?(5)=V " " ??=G
260 ;=P&1=1 L(O)=V L(O+1)=A O=O+2         ** PASS1なら行番号を格納
265 G=G+3
270* ;=L(3)>0 #=290
275 ;=G:-1)=" " #=300                     ** 通常文
280 ;=G:-1)="*" #=910                     ** コメント文の処理へ
290* ;=G:-1)="-" L(3)=1-L(3) #=910
295* ;=L(3)>0 #=910
300** 文の左辺と右辺を処理
310 N=G:0) ;=P=1 " " $=N "="              ** まず左辺を評価
350 ;=N="#" #=1000
360 ;=N="!" #=1000
370 ;=N="]" #=1100
380 ;=N="/" G=G+1 W=5 !=5390 #=700        ** BIOS #05 割り算ルーチンへ(FPGAではめんどい)
390 ;=N=""" #=2300
400 ;=N="?" Z=6 #=2500
410 ;=(N>="A")*(N<="Z") #=5000            ** 変数(A-Z)
420 ;=N=";" #=5500
430 ;=N="@" #=5550
440 ;=N="." Z=11 #=2500                   ** 空白出力
445 ;=N=">" G=G+2 !=500 W=K !=8050 #=700  ** >= 機械語へジャンプ(JSR)
450 ;=N="<" G=G+1 #=5340                  ** <= ポート出力
455 ;=N="$" ;=G:1)="=" G=G+2 W=1 #=5360   ** $= SIO出力(SUB経由) W=1 呼び出し番号
460 ;=N="$" ;=G:1)="$" G=G+3 !=3000 #=700 ** $$はregAロードするが変数には格納しない
470 ;=N="$" !=5400 #=700                  ** $xxxxxxxx 機械語直接入力 
475 ;=N="'" Z=0 #=5010                    ** 乱数初期化(未処理) Zにシードを入れる
480 ;=N=" " #=700
485 ;=N="*" #=920                         ** 文頭の*以降はコメント
490 ;=N="[" #=920                         ** 拡張命令はコメント扱い
495 W=495 #=8499
499** 数字(10進16進)処理
500 K=0 ;=G:0)="$" G=G+1 #=530
510 E=G:0)-$30 ;=(E<0)+(E>9) ] ** Kに数値が入る
520 K=K*10+E G=G+1 #=510
530 E=G:0) E=E-($30*(E<"A"))-($37*(E>"9")) ** 16進
540 ;=(E<0)+(E>15) #=560
550 K=K*16+E G=G+1 #=530
560 ;=G:-1)<>"$" ]
570 W=2 !=5390 ]   ** A=$  CALL BIOS(2) 
700** 文の終わりを判定
710 !=800                  ** 最適化処理へ
720 ;=G:0)=0 G=G+1 #=200   ** 行が終了、次の行へ
730 ;=G:0)=" " G=G+1 #=720
740 #=300                  ** 次の文へ
800 ]                                   ** 文単位の最適化(一通り完成したら見直すかも)
890*
900** REM **
910* W=$0F !=8230                        ** 行コメントを判りやすくする為NOPを挿入(無駄なら削除)
920 ;=G:-1)>0 G=G+1 #=920
930 #=200
1000 ;=G:1)<>"=" W=1000 #=8499
1010 G=G+2 !=1400                       ** JMP/JSR
1020 #=700
1100 G=G+1 W=0 ;=G:0)="]" G=G+1 W=1     ** ']'の処理 ']]'はRTS 2とする(が使わず)
1110 W=$C2+W !=8230 #=700               ** RTS(SP-2)
1400 ;=G:0)="-" G=G+1 !=500 K=$7FFF #=1500 ** #=-1
1410 !=500 ** Kに数値
1500*                                ** #/!/; のいずれかの処理
1520* ;=P&1=1 A=A+3 ]  ** JMPの登録     ** Bxの長さをセット
1530 !=1590                          ** ラベルの検索
1550 ;=N="!" W=$DE !=8130 ]        ** != JSR  
1560 ;=N=";" W=$D8 !=8130 ]        ** ;= JZ
1570         W=$FE !=8130 ]        ** #= JP
1590 J=-2+$20 @ J=J+2 @=(L(J)>=K) ]          ** Kで番号検索、Jにテーブル位置が入る
2300 W=$DF !=8230 W=$0000 !=8200 W=10 !=5390 ** regA < rtn BIOS(10).Call
2310 A=A I=0 G=G+2                           ** '"'の処理
2320 @ A:I)=G:I-1) I=I+1                     ** 文字列をカウント(I)しながら格納 
2330 @=(G:I-1)=""") G=G+I A:I)=0             ** """が見えたら完了 末尾に0を
2340 A=A-5 W=I+6 !=8070 A=A+I+4
2341* A=A-5 W=(A-S+R)+I+6 !=8200 A=A+I+4
2350 #=700
2500 W=G:1) ;=W<>"=" #=2600
2510 G=G+2 W=$FF !=8230 W=$0000 !=8200 W=$E9 !=8230 #=2900 ** ?= BIOS(6) Call
2600 ;=W<>"?" #=2700 
2610 G=G+3 Z=7 #=2900                     ** ??=
2700 ;=W<>"$" #=2800 
2710 G=G+3 Z=8 #=2900                     ** ?$=
2800 ;=W<>"(" W=2800 #=8499 ** Err
2810 G=G+1 !=4000 G=G+1 W=$EE8 !=8230 Z=6 ** ?(X)= !=4000での(SP)の数値は無視される
2900 !=3000                               ** 右辺を処理
2910 ;=Z=6 W=$E1 !=8230                   ** ?=の場合、桁数(B)をPUSHしているのでPOPする
2920 W=Z !=5390 #=700 ** Call 
2950 !=3000 ]                             ** 右辺の評価
2990*
3000 !=4000 ** 右辺の処理　4000[項]->3200[演]->4000[項]->3200[演]でループする
3200 H=G:0) G=G+1 ;=P=1 " " $=H
3205 ;=H="+" !=4000 H=$01 #=3500 ** ADD
3210 ;=H="-" !=4000 H=$02 #=3500
3212 ;=H="&" !=4000 H=$03 #=3500
3214 ;=H="|" !=4000 H=$04 #=3500
3216 ;=H="^" !=4000 H=$05 #=3500
3220 ;=H="*" !=4000 H=$06 #=3500
3230 ;=H="/" !=4000 H=$0F #=3500
3240 ;=H="=" !=4000 H=$08 #=3500
3250 ;=H="<" #=3400
3260 ;=H=">" #=3450
3270 ;=H=")" !=8150             ** PULL (SP+1)<-(SP) & SP++ **************
3280 G=G-1 ]                    ** 右辺評価完了
3290*
3400 ;=G:0)=">" G=G+1 !=4000 H=13 #=3500  ** '<>' NE の処理
3410 ;=G:0)="=" G=G+1 !=4000 H=12 #=3500  ** '<=' LE の処理
3420                  !=4000 H=11 #=3500  ** '<'  LT の処理
3450 ;=G:0)="=" G=G+1 !=4000 H=10 #=3500  ** '>=' GE の処理
3460 ;=G:0)=">" G=G+1 !=4000 H=7  #=3500  ** '>>' SR の処理
3470                  !=4000 H=9  #=3500  ** '>'  GT の処理
3500 !=3600 #=3200              ************  ループへ
3560* #=4399 W=1 !=8160 !=4000 W=3 !=5390 W=2 !=8170 ] ** 割り算処理挿入
3599** 演算による補正(+-*/=)
3600 ;=(X&$C0)=$40 A:-1)=$20+A:-1) ** 計算命令(Xに格納)を確認,STAをSTBに変更
3605 ;=H=14 #=3620
3610 ;=X=$DF A:-3)=$FF  ** LIA    -> LIB
3615 ;=X=$D7 A:-2)=$F7  ** LIA(S) -> LIB(S)
3620* ;=X=$C4 W=$1A !=8230
3630 ;=X=$E1 A=A-1 W=$19 !=8230 W=$E0 !=8230
3640 ;=H=$0F W=3 !=5390 #=3660     ** 割り算"/"の場合はBIOS(3)を呼び出し
3650 W=H !=8230                    ** 演算子(+-.etc)を格納
3660 ;=P=1 "(" ?$=H ")" 
3670 ]
3999** 項の評価
4000 H=G:0) G=G+1 ;=P=1 " " $=H
4005 ;=H="$" ;=G:0)="$" G=G+2 ]         ** =$$ regAの値を格納
4010 ;=(H>="0")*(H<="9")+(H="$") #=4210
4020 ;=H=""" #=4200
4030 ;=H="&" K=L(1)-S+R #=4220
4040 ;=(H<"A")+(H>"Z") #=4500
4050 W=G:0) ;=(W>="A")*(W<="Z") G=G+1 #=4050
4060 H=(H-"A")+2                                   ** 右辺の変数(A-Z)
4070 ;=W=":" #=4300
4080 ;=W="(" #=4350
4090 !=8110 ]
4200 K=G:0) G=G+2 #=4220
4210 G=G-1 !=500 ;=G:-1)="$" ] ** !=500するとKに数値が入る
4220 !=8080 ]
4299** メモリ配列
4300 W=1 !=4400 #=4550                  ** =X:Y) メモリ参照
4350 W=2 !=4400 #=4550                  ** =X(Y) メモリ参照
4400 !=8280 W=$E8 !=8230 W=H !=8280 W=1 G=G+1 !=3000 ** 右辺の処理
4401* !=8280 W=$1A !=8230 W=H !=8280 W=1 G=G+1 !=3000 ** 右辺の処理
4410 A=A-1 !=8250                       ** 右辺をPUSHする
4420 !=8290 W=$40+W !=8230 !=8250
4430 !=8290 W=$C4+W-1 !=8230 W=$E1 !=8230 ]          ** 読み出し実行
4500 ;=H<>"(" #=4600                    ** 右辺の特殊文字評価
4510 !=8250 !=3000                      ** '('を検出 PUSHして')までを処理
4550 ;=G:0)<>")" W=4550 #=8499
4560 G=G+1 ]
4600 ;=H<>"'" #=4700
4610 W=4 !=5390 ] ** BIOS(4)               ** 乱数(使用予定が無いので未処理)
4700 ;=H<>"%" #=4800
4710 W=$40+$19+3 !=8230 ]                  ** 余り(%)はZ+1の位置
4800 ;=H="-" !=4000 H=14 #=3600 ** 0から引く
4801* ;=H="-" K=0 !=8080 !=4000 H=02 #=3600 ** 0から引く
4810 ;=H="+" !=4000 H=$39 #=3600           ** 負数は使わないので無視
4820 ;=H="#" K=0 !=8080 !=4000 H=08 #=3600 ** 0なら1、以上なら0(有ってるか?)
4830 ;=H="?" W=9 !=5390 ]
4840 ;=H="<" #=4890                        ** 入力 <(n)
4850* ;=(H="@") ;=G:0)="(" #=4870
4860 W=4860 #=8499
4870 G=G+1 !=500 G=G+1 ;=K>0 H=K !=8110  ] ** (SP) <- @(n)
4890 !=500 H=K W=K !=8280  ** ?? (SP) <- IN
4895 W=$FF !=8230 !=8290 !=8200 W=$1F !=8230 ] ** INPUT
5000 Z=(G:0)-"A")+2                            ** 変数の左辺の計算
5005 W=G:1) ;=(W>="A")*(W<="Z") G=G+1 #=5005   ** 読み飛ばし
5010 ;=W="=" #=5300                            ** =に到達
5020 ;=W=":" W=1 #=5200  ** A:X)=
5030 ;=W="(" W=2 #=5200  ** A(X)=
5090 W=5090 #=8499 ** 分類不明エラー
5199*
5200 !=8280 W=1 G=G+2 !=3000 A=A-1 ** A(X)=の項(X)を処理 
5210 ;=G:0)<>")" W=5200 #=8499
5220 !=8250                        ** (SP) <- A(配列の添え字)
5230 W=$40+Z !=8230 !=8250         ** (SP) <- 配列変数
5240 G=G+2 !=3000                  ** Areg <- 右辺
5250 !=8290 W=$C6+W-1 !=8230 #=700 ** FPGA内でメモリ格納処理
5290*
5300 G=G+2 !=3000 !=8100 #=5600
5340 !=500 W=K !=8280 G=G+1 !=3000                ** ポート出力  < <- (SP)
5350 W=$FF !=8230 !=8290 !=8200 W=$3F !=8230 #=700
5360 !=8280 !=3000 !=8290 !=5390 #=700            ** SIO出力(#01) 3000でKに数値 1590でJ=Table位置
5380* W=5380 #=8499 K=L(5)+W !=1590 W=$DE !=8130 ] ** BSR xx
5390 K=L(5)+W !=1590 W=$DE !=8130 ]               ** CALL xx
5400 G=G+1 
5410 !=5430 ;=G:0)>=$30 #=5410
5420 ]
5430 !=5440 G=G+1 W=E !=5440 G=G+1 W=W*16+E !=8240 ] *** A:0)=W A=A+1 ]
5440 E=G:0) E=E-($30*(E<"A"))-($37*(E>"9")) ] ** 16進
5500 ;=G:1)<>"=" #=8499  ** ';'
5510 G=G+2 !=3000 
5530 K=V+1 !=1510 #=700 ** if(;)文のJUMP RA=0で次の行へ
5549** '@'関連の処理
5550 ;=G:1)<>"(" #=5580
5560 G=G+2 !=500 W=K !=8280 G=G+2 !=3000 !=8290 K=W ;=K>0 Z=K !=8100 ** @(A)=B
5570 #=700
5580 G=G+1 ;=G:0)="=" #=5700
5590 W=$DE !=8230 W=2 !=8070 #=700            ** '@ 'の処理 PUSH rtn
5600 ;=G:0)<>"," #=700
5610 G=G+1 !=3000                             ** For(A=1,5)の処理
5620 !=8250 W=$DE !=8230 W=2 !=8070 #=700     ** K(終了値)と戻り番地をPUSH
5650 G=G+1 ;=G:0)="=" #=5700
5700 Z=G:1) G=G+1 !=3000                      ** '@=' ()内の計算
5710 ;=(Z>="A")*(Z<="Z") Z=(Z-"A")+2 !=8100 #=5740 ** A=A+1してから'@=A+1'の処理へ
5720 W=$D9 !=8230 W=5 !=8070                  ** @=(A>5) 成立(1)なら次へ
5730 W=$C8E8 !=8200 W=$C2E0 !=8200 #=700      **         不成立(1)なら'@'の次に戻る
5740 W=$19C9 !=8200 W=$0BD9 !=8200 W=5 !=8070
5750 W=$C8E8 !=8200 W=$C2 !=8230 W=$E0E0 !=8200 #=700
7999*
8000** NEW SUB 
8050 !=8280 W=$DE !=8230 !=8290 !=8200 ] ** Wの番地にJSR >=$100
8070 W=(A-S)+R+W !=8200 ]                ** 現在位置+W
8080 ;=K<256 W=$D7 !=8230 W=K !=8240 ]   **     (1byte)
8085 W=$DF !=8230 W=K !=8200 ]           ** 定数(2byte)の格納
8100 W=$80+Z !=8230 ]                    ** A= ST
8110 W=$40+H !=8230 ]                    ** =A LD
8130 !=8230 W=(L(J+1)-S)+R !=8200 ]      ** Bx
8150 W=$E1 !=8230 ]            ** ｽﾀｯｸ移動
8190 W=$0F !=8230 ]            ** NOP
8200 A:0)=W/256 A:1)=W A=A+2 ] ** 数値を68形式で格納
8210 W=A:0)*256+A:1) ]         ** 数値を68形式で読出
8230 A:0)=W X=W A=A+1 ]        ** 命令(1byte)書き込み Xに命令を格納
8240 A:0)=W A=A+1 ]            ** 1byte書き込み
8250 W=$E8 !=8230 ]            ** PUSH A
8280 U(0)=W U=U+2 ] ** WをPUSH
8290 U=U-2 W=U(0) ] ** WにPOP
8300** FPGA OUT ** S=開始 A=最終
8310 ;=P=2 W=S Y=0 Z=L(2)+2 @ !=8370 W=W+U Y=Y+U @=(W>=A) ** 逆アセンブル
8315* J=-2+$20 @ J=J+2 / ?(5)=L(J) " " ??=L(J+1)-S+R @=(J>=O) ** ラベル表示
8320* [mr rom.v
8330* [mc pram.coe 
8340 [mh pram.hex // "Hex作成"
8350 [cw "　クリップ作成"
8360 ]
8370 / " " ??=Y+R " " X=W:0) !=8400 ": " ?$=W:0) ;=U>1 " " ?$=W:1) ;=U>2 " " ?$=W:2) #=8390
8380 "   " ;=U=1 "   "
8390 J=-2+$20 @ J=J+2 ;=((L(J+1)-S)=Y) ;=L(J)<>$7FFF " ; " ?=L(J) @ $=Z:0) Z=Z+1 @=(Z:0)=0) Z=Z+3
8395 @=(J>=O) ]
8400 U=1
8410 ;=X=15 "NOP" ]
8411 ;=X=01 "ADD" ]
8412 ;=X=02 "SUB" ]
8413 ;=X=03 "AND" ]
8414 ;=X=04 "OR " ]
8415 ;=X=05 " ^ " ]
8416 ;=X=06 "MUL" ]
8416 ;=X=07 "SR " ]
8418 ;=X=08 "EQU" ]
8419 ;=X=09 "GT " ]
8420 ;=X=10 "GE " ]
8421 ;=X=11 "LT " ]
8422 ;=X=12 "LE " ]
8423 ;=X=13 "NE " ]
8424 ;=X=14 "NEG" ]
8425 ;=X=$12 "MCA" ]
8426 ;=X=$13 "MDA" ]
8427 ;=X=$1F "IN " ]
8428 ;=X=$3F "OUT" ]
8429 ;=X=$38 "STS" ]
8430 ;=X=$19 "MAB" ]
8431 ;=X=$1A "XBA" ]
8432 ;=X=$39 "MBA" ]
8442 ;=X&$F8=$E0 "POP" ]
8443 ;=X&$F8=$E8 "PSH" ]
8444 ;=X=$FE "JMP" U=3 ]
8445 ;=X=$D8 "JZ " U=3 ]
8446 ;=X=$D9 "JNZ" U=3 ]
8447 ;=X=$DE "JSR" U=3 ]
8451 ;=X=$D7 "LIA" U=2 ]
8452 ;=X=$DF "LIA" U=3 ]
8453 ;=X=$F7 "LIB" U=2 ]
8454 ;=X=$FF "LIB" U=3 ]
8461 X=X&$FE
8462 ;=X=$C2 "RTS" ]
8463 ;=X=$C4 "LDM" ]
8464 ;=X=$C6 "STM" ]
8465 ;=X&$FC=$C8 "PEA" ]
8466 ;=X&$FC=$CC "POA" ]
8470 X=X&$E0
8471 ;=X=$00 "-C-" ]
8472 ;=X=$40 "LDA" ]
8473 ;=X=$60 "LDB" ]
8474 ;=X=$80 "STA" ]
8475 ;=X=$A0 "STB" ]
8479         "(-)" ]
8499 // "** Err.C" ?=W  " Line= " ?=V / #=90
